\documentclass{cognito}
\usepackage{lmodern}
\usepackage{mathtools}
\usepackage{textpos}

\begin{document}

% Some options
\lstset{language=C}
\lstset{mathescape=true}

% For links use
% \hyperref[note:Heuristic Minimax]{\emph{Heuristic Minimax}}

\begin{note}{Programming}
	\tags{Daniel Balle 2018}
\end{note}

\begin{note}{Iterators}
	Sequence containers like {\it vectors} or {\it strings} offer random access iterators for
	either ordered traversal using \incode{begin} and \incode{end},
	or reversed traversal with \incode{rbegin} and \incode{rend}.
	
	\begin{largecode}
 c = some container
 for (auto it = c.begin(); it != c.end(); i++) ...
 for (auto rit = c.rbegin(); rit != c.rend(); i++)
 	// use *rit
	\end{largecode}
	\begin{remark}
		Such containers can be used for \hyperref[note:Range-Based For Loop]{\it range-based} for loops.
	\end{remark}
	\vspace{-5pt}
	\tags{C++, Data Structures, Iteration}
\end{note}

\begin{note}{Range-Based For Loop}
	Range-based for loops are used to execute statements through any \incode{range}
	defined by \hyperref[note:Iterators]{\it iterators} \incode{begin} and \incode{end}.
	
	\begin{largecode}
 for (auto & i : c ) ...
	\end{largecode}
	\begin{remark} Using a reference \incode{\&} is almost always preferred.
		For {\it read-only} purposes, preface with \incode{const}.
	\end{remark}\vspace{-5pt}
	\tags{C++, Data Structures, Iteration}
\end{note}

% iterating over a map gives pairs. x.first and x.second give key and value

\begin{note}{Element Access}
	Noteworthy element access functions are \incode{front} and \incode{back}
	which return a direct reference for respectively the first and last element of a sequence
	container.
	
	\begin{largecode}
 c = some container
 c.front() += 10;
 c.back() = 42;
	\end{largecode}
	\begin{remark} Complement basic functions \incode{operator[]} and \incode{at}. \end{remark}
	\vspace{-5pt}
	\tags{C++, Data Structures, Access}
\end{note} 

\begin{note}{constexpr}
	\incode{constexpr}
\end{note}


\begin{note}{Sorting}
%	\begin{textblock*}{\textwidth}(8.25cm,-0.7cm)
%		\incode{<algorithm>}
%	\end{textblock*}
	\incode{std:sort} can be used to sort elements in a range defined by random access \hyperref[note:Iterators]{\it iterators} \incode{[first, last)}
	using either the default \incode{operator<} or a custom \emph{binary} function \incode{cmp}.
	\begin{largecode}
 #include <algorithm>
 bool cmp(const Type1 &a, const Type2 &b) { ... }
 sort(c.begin(), c.end())
 sort(c.begin()+4, c.end(), cmp)
	\end{largecode}
	Performs $O(n \log_2 n)$ comparison according to the {\tt C++} standard. Implementations differ
	but usually use {\it introsort} or hybrids.
	\begin{remark} For a \emph{stable} sorting algorithm, use \incode{stable\_sort}. \end{remark} \vspace{-5pt}
	\tags{C++, Sorting}
\end{note}

\begin{note}{String Stream}
	Type \incode{stringstream} defined in \incode{sstream} allows
	a string to be treated like a stream, thus allowing extraction \incode{<<} and insertion \incode{>>}.
	\begin{largecode}
 #include <iostream>
 #include <sstream>
 string s, int i;
 getline(cin, s);
 stringstream(s) >> i;
	\end{largecode}
	\vspace{-5pt}
	\tags{C++, I/O, Streams, Strings}
\end{note}

% const int * p;  read-only pointer, we can't change the int. We can change p though.
% int * const p; can't point elsewhere, but we can change the int.

\begin{note}{Reverse}
	\begin{largecode}
 std:reverse(c.begin(), c.end())
 	\end{largecode}
\end{note}

\begin{note}{Vector}
	\tags{C++, Data Structures}
\end{note}


\end{document}




